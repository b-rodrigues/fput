---
output:
  pdf_document: default
  html_document: default
---
# Functional Programming {#fprog}

## Introduction {#fprog_intro}

### Function definitions

As mentioned in the [functional programming overview](#funcprog_overview) functional programming
is one of the numerous ways to write code. In functional programming, you write functions that
do the computations and then as the user, you call these functions to work for you.

You should be familiar with function definitions in R. For example, suppose you want to compute
the square root of a number and want to do so using Newton's algorithm:

```{r square_root_loop}
sqrt_newton <- function(a, init, eps = 0.01){
    while(abs(init**2 - a) > eps){
        init <- 1/2 *(init + a/init)
    }
    return(init)
}
```

You can then use this function to get the square root of a number:

```{r}
sqrt_newton(16, 2)
```

We are using a `while` loop inside the body^[The *body* of a function are the instructions that
define the function. You can get the body of a function with `body(some_func)`] of the function. 
In *pure* functional programming languages, like Haskell, you don't have loops. How can you 
program without loops, you may ask? In functional programming, loops are replaced by recursion. 
Let's rewrite our little example above with recursion:

```{r square_root_recur}
sqrt_newton_recur <- function(a, init, eps = 0.01){
    if(abs(init**2 - a) < eps){
        result <- init
    } else {
        init <- 1/2 * (init + a/init)
        result <- sqrt_newton_recur(a, init, eps)
    }
    return(result)
}
```

```{r}
sqrt_newton_recur(16, 2)
```

R is not a pure functional programming language though, so we can still use loops (be it `while` or
`for` loops) in the bodies of our functions. Actually, for R specifically, it is better,
performance-wise, to use loops instead of recursion, because R is not tail-call optimized. I won't
got into the details of what tail-call optimization is but just remember that if performance is 
important a loop will be faster. However, sometimes, it is easier to write a function using 
recursion. I personally tend to avoid loops if performance is not important, because I find that 
code that avoids loops is easier to read and debug. However, knowing that you have can use loops, 
options is reassuring. In the coming sections I will show you some built-in function that make it
possible to avoid writing loops and that don't rely on recursion, so performance won't be 
penalized.

### Properties of functions

Mathematical functions have a nice property: we always get the same output for a given input. This
is called referential transparency and we should aim to write our R functions in such a way.

For example, the following function:

```{r}
increment <- function(x){
    return(x + 1)
}
```

Is a referential transparent function. We always get the same result for any `x` that we give to 
this function. 

This:

```{r}
increment(10)
```

will always produce `11`.

However, this one:

```{r}
increment_opaque <- function(x){
    return(x + spam)
}
```

is not a referential transparent function, because its value depends on the global variable `spam`.


```{r}
spam <- 1

increment_opaque(10)
```

will only produce `11` if `spam = 1`. But what if `spam = 19`? 


```{r}
spam <- 19

increment_opaque(10)
```

To make `increment_opaque()` a referential transparent function, it is enough to make `spam` an
argument:

```{r}
increment_not_opaque <- function(x, spam){
    return(x + spam)
}
```

Now even if there is a global variable called `spam`, this will not influence our function:

```{r}
spam <- 19

increment_not_opaque(10, 34)
```

This is because the variable `spam` defined in the body of the function is a local variable. It 
could have been called anything else, really. Avoiding opaque functions makes our life easier.

Another property that adepts of functional programming value is that functions should have no, or
very limited, side-effects. This means that functions should not change the state of your program.

For example this function (which is not a referential transparent function):

```{r square_root_loop_side_effects}
count_iter <- 0

sqrt_newton_side_effect <- function(a, init, eps = 0.01){
    while(abs(init**2 - a) > eps){
        init <- 1/2 *(init + a/init)
        count_iter <<- count_iter + 1 # The "<<-" symbol means that we assign the
    }                                 # RHS value in a variable in the global environment
    return(init)
}
```

If you look in the environment pane, you will see that `count_iter` equals 0. Now call this
function with the following arguments:

```{r}
sqrt_newton_side_effect(16000, 2)

print(count_iter)
```

If you check the value of `count_iter` now, you will see that it increased! This is a side effect,
because the function changed something outside its scope. It changed a value in the global
environment. In general, it is good practice to avoid side-effects. For example, we could make the
above function not have any side effects like this:

```{r square_root_loop_not_more_side_effects}
sqrt_newton_count <- function(a, init, count_iter = 0, eps = 0.01){
    while(abs(init**2 - a) > eps){
        init <- 1/2 *(init + a/init)
        count_iter <- count_iter + 1
    }
    return(c(init, count_iter))
}
```

Now, this function returns a list with two elements, the result, and the number of iterations it
took to get the result:

```{r}
sqrt_newton_count(16000, 2)
```

Writing to disk is also considered a side effect, because the function changes something (a file)
outside its scope. But this cannot be avoided (and it's actually a good thing to have, functions
that can write to disk) so just remember: try to avoid having functions changing variables in the
global environment unless you have a very good reason of doing so.

Finally, another property of mathematical functions, is that they do one single thing. Functional
programming purists also program their functions to do one single task. This has benefits, but
can complicate things. The function we wrote previously does two things: it computes the square 
root of a number and also returns the number of iterations it took to compute the result. However,
this is not a bad thing; the function is doing two tasks, but these tasks are related to each other
and it makes sense to have them together. My piece of advice: avoid having functions that do too 
many *unrelated* things. This makes debugging harder.

In conclusion: you should strive for referential transparency, try to avoid side effects unless you
have a good reason to have them and try to keep your functions short and do as little tasks as 
possible. This makes testing and debugging easier, as you will see.

## `Map()` and `Reduce()`

No introduction to functional programming would be complete without some discussion about the 
functions `Map()` and `Reduce()`. `Map()` allows you to map your function to every element of a 
list of arguments and is easy to understand, while `Reduce()` (sometimes called `fold()` in other 
programming languages) *reduces* a list of values to a single value by successively applying a
function. It's a bit harder to understand, but with some examples it will become clear soon 
enough.

### `Map()`

Now that we have our nice function that computes square roots using Newton's algorithm, we would
like to compute the square root of every element in the following list:

```{r}
numbers <- c(16, 25, 36, 49, 64, 81)

sqrt_newton(numbers, init = rep(1, 6), eps = rep(0.001, 6))
```

We get a whole bunch of nasty warning messages.

That is because the condition `(init^2 - a) > eps` does not make sense for vectors. Here, R tells 
the user that it only uses the first element and then does the computation anyways. I would prefer
if R would stop the execution and print an error message. This would force the user to
have to rewrite the function to explicitly take vectors into account. And there is a very simple
way of doing it, by using the function `Map()`:

```{r}
Map(sqrt_newton, numbers, init = 1)
```

`Map()` applies a function to every element of a list and returns a list. 

We could then write a wrapper around `Map()`:

```{r}
sqrt_newton_vec <- function(numbers, init, eps = 0.01){
    return(Map(sqrt_newton, numbers, init, eps))
}

sqrt_newton_vec(numbers, 1)
```

As you can see, we can give a function as an argument to another function. This makes `Map()`
a *higher-order function*. This is another important concept in functional programming.

R has other higher-order functions that work like `Map()`, such as 
`apply(), lapply(), mapply(), sapply(), vapply()` and `tapply()`.
Depending on what you want to do, you will have to use one or the other. `apply()` and 'tapply()' 
are different from the other `*apply()` functions, because they work on arrays. You can apply a 
function on the rows or columns of an array, for example if you want a row-wise sum:

```{r}
a <- cbind(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9))
apply(a, 1, sum)
```

We could use `lapply()` instead of `Map()`:

```{r}
lapply(numbers, sqrt_newton, init = 1)
```

or `sapply()`:

```{r}
sapply(numbers, sqrt_newton, init = 1)
```

`mapply()` is different from these two:

```{r}
inits <- c(100, 20, 3212, 487, 5, 9888)
mapply(sqrt_newton, numbers, init = inits)
```

What happens here is that `sqrt_newton()` gets called with following arguments:

```{r}
sqrt_newton(numbers[1], inits[1])
sqrt_newton(numbers[2], inits[2])
sqrt_newton(numbers[3], inits[3])
sqrt_newton(numbers[4], inits[4])
sqrt_newton(numbers[5], inits[5])
sqrt_newton(numbers[6], inits[6])
```

From the `Map()`'s documentation, we learn that:

    `Map()` is wrapper to `mapply()` which does not attempt to simplify the result... 

All this behaviour can be replicated using loops, but once you get the gist of these functions, you
can write code that is shorter and easier to read and unlike in the case of recursion, without any
loss in performance (but without any gains either).

### `Reduce()`

`Reduce()` is another very useful higher-order function, especially if you want to avoid loops to 
make your code easier to read. In some programming languages, `Reduce()` is called `fold()`.

I think that the following example illustrates the power of `Reduce()` well:

```{r}
Reduce(`+`, numbers, init = 0)
```

Can you guess what happens? `Reduce()` takes a function as an argument, here the function 
`+`^[This is simply the `+` operator you're used to. Try this out: `` `+`(1, 5) `` 
and you'll see `+` is a function like any other. You just have to write backticks around the plus 
symbol to make it work.] and then does the following computation:

```
0 + numbers[1] + numbers[2] + numbers[3]...
```

It applies the user supplied function successively but has to start with something, so we give it
the argument `init` also. This argument is actually optional, but I show it here because in some 
cases it might be useful to start the computations at another value than `0`. This function 
generalizes functions that only take two arguments. If you were to write a function that returns 
the minimum between two numbers:

```{r}
my_min <- function(a, b){
    if(a < b){
        return(a)
    } else {
        return(b)
    }
}
```

You could use `Reduce()` to get the minimum of a list of numbers:

```{r}
Reduce(my_min, numbers)
```

Here we don't supply an `init` because there is no need for it. Of course R's built-in `min()` 
function works on a list of values. But `Reduce()` is a very powerful function that can make our 
life much easier and most importantly avoid writing clumsy loops.

This is the end of the introduction to functional programming. Entire books have been written on
the subject, such as the upcoming book by @khan2017 or @lipovaca2011. If you're curious about 
functional programming, you should read these books. For our purposes though, knowing how to write
functions, and trying to make them referentially transparent as well as knowing about `Map()` and
`Reduce()` is enough to get us going.

## Wrap-up

* Make your functions referentially transparent
* Avoid side effects (if possible)
* Make your functions do one thing (if possible)
* A function that takes another function as an argument is called an higher-order function. You 
can write your own higher-order functions and this is a way of having short and easily testable
functions. Making these functions then work together is trivial and is what makes functional 
programming very powerful.
