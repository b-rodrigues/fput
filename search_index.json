[
["index.html", "Functional programming and unit testing for data munging Chapter 1 Why this book? 1.1 Motivation 1.2 Who am I? 1.3 Thanks", " Functional programming and unit testing for data munging Bruno Rodrigues 2016-08-18 Chapter 1 Why this book? This short book serves to show how functional programming and unit testing can be useful for the task of data munging. This book is not an in-depth guide to functional programming, nor unit testing with R. If you want to have an in-depth understanding of the concepts presented in these books, I can’t but recommend Wickham (2014) and Wickham (2015) enough. Here, I will only briefly present functional programming, unit testing and building your own R packages. Just enough to get you (hopefully) interested and going. This book is not an introduction to R either. I will assume that you have intermediate knowledge of R. 1.1 Motivation Functional programming has very nice features that make working on data sets much more pleasant. It is common that you have to repeat the same instructions over and over again for different data sets that look very similar (for example, same, or similar column names). Of course, it is possible to loop over these data sets and repeat a set of instructions that change these data sets. However, we will see why a functional programming approach is to be preferred. Unit testing then allows you to make sure that the functions you want to apply to your data sets actually do what you really want them to do. Knowing and applying these two concepts together will make you hopefully a better data analyst. 1.2 Who am I? I use R daily at my current job, and discovered R some years ago while I was at the University of Strasbourg. I’m not an R developer, and don’t have a CS background. Most, if not everything, that I know about R is self-taught. I hope however that you will find this book useful. You can follow me on twitter or check my blog. 1.3 Thanks I’d like to thank Ross Ihaka and Robert Gentleman for developing the R programming language. Many thanks to Hadley Wickham for all the wonderful packages he developed that make R much more pleasant to use. Thanks to Yihui Yie for bookdown without which this book would not exist (at least not in this very nice format). Thanks to Hans-Martin von Gaudecker for introducing me to unit testing and writing elegant code. The PEP 8 style guidelines will forever remain etched in my brain. Finally I have to thank my wife for putting up with my endless rants against people not using functional programming nor testing their code (or worse, using proprietary software!). References "],
["intro.html", "Chapter 2 Introduction 2.1 Getting R 2.2 A short overview of functional programming 2.3 A short overview of unit testing", " Chapter 2 Introduction 2.1 Getting R Since I’m assuming you have an intermediate level in R, you already should have R and Rstudio installed on your machine. However, you may lack some of the following packages that are needed to follow the examples in this book: covr dplyr lazyeval lubridate memoise readr roxygen2 stringr testthat tibble tidyr If you’re missing some or all of these packages, install them. You’ll notice that most, if not all, of these packages were authored or co-authored by Hadley Wickham, currently chief scientist at Rstudio. 2.2 A short overview of functional programming What is functional programming? Wikipedia tells us the following: In computer science, functional programming is a programming paradigm —a style of building the structure and elements of computer programs— that treats computation as the evaluation of mathematical functions and avoids changing state and mutable data. It is a declarative programming paradigm, which means programming is done with expressions or declarations instead of statements. In functional code, the output value of a function depends only on the arguments that are input to the function, so calling a function f twice with the same value for an argument x will produce the same result f(x) each time. Eliminating side effects, i.e. changes in state that do not depend on the function inputs, can make it much easier to understand and predict the behavior of a program, which is one of the key motivations for the development of functional programming. That’s the first paragraph of the Wikipedia page and it’s quite heavy already! So let’s try to decrypt what is said in this paragraph. Functional programming is a programming paradigm. You may have heard of object oriented programming, or imperative programming before. You actually probably program in an imperative way without knowing it. Imperative programming is usually how programming is taught at universities, and most people then keep on programming in this way. Usually, people that write code in an imperative way tend to write very long scripts that change the state of the program gradually. In the case of a statistician (I will use the word ‘statistician’ to mean any person that works with datasets. Be it an economist, biologist, data scientist, etc.) this usually means loading a dataset, doing whatever you have to do by writing each step on a file, then running everything. Sometimes you have to save temporary datasets, and then write other scripts that do a series of computations on these temporary datasets and then not forget to delete said temporary datasets. Functional programming is different, in that you write functions that do one single task and then call these functions successively on your data set. These functions can be used for any other project, can be documented and tested. It is also easier to automate tasks and navigate through the code. Since one function does one single task, if you’re looking for the line of code that creates variable X, just look in the function called create_var_X(), instead of scrolling aimlessly through a 1000 lines long script. You can also be sure that your functions do not do anything else (basically, this is what is meant by “eliminating side effects”) than the single task you gave them. You can trust your functions. 2.3 A short overview of unit testing At the end of the last section I wrote that you can trust your functions. Is that true though? Functional programming can make your life easier, but it does not prevent you from introducing bugs in your code. However, what functional programming makes easily possible, is to very easily and effectively test your code thanks to unit testing. You probably already test your code, by hand. You write some loop that is supposed to sum the first 10 integers and then you try it out and check if, indeed, your loop returns 55. Because this is the correct result, you save your work and continue programming something else, and so on. Unit testing is this, but in an automated way. Instead of just trying things out in the interpreter, you write unit tests. You write code that actually checks your functions. You save this unit tests somewhere, and then re-run them whenever you make changes to your code. Even if you don’t change some parts of your code, you re-run every unit test. Because you actually never know what may happen. Maybe changing a single line in one of your functions introduced some unforeseen consequences that breaks functionality some place else. When you change code, and all your unit tests still pass, then you can be confident that your code is correct (actually, don’t be too confident, because maybe you didn’t write enough unit tests to cover every case. But we will see how we can be sure there is enough coverage). "],
["fprog.html", "Chapter 3 Functional Programming 3.1 Introduction 3.2 Map() and Reduce() 3.3 Wrap-up", " Chapter 3 Functional Programming 3.1 Introduction 3.1.1 Function definitions As mentioned in the functional programming overview functional programming is one of the numerous ways to write code. In functional programming, you write functions that do the computations and then as the user, you call these functions to work for you. You should be familiar with function definitions in R. For example, suppose you want to compute the square root of a number and want to do so using Newton’s algorithm: sqrt_newton &lt;- function(a, init, eps = 0.01){ while(abs(init**2 - a) &gt; eps){ init &lt;- 1/2 *(init + a/init) } return(init) } You can then use this function to get the square root of a number: sqrt_newton(16, 2) ## [1] 4.00122 We are using a while loop inside the body1 of the function. In pure functional programming languages, like Haskell, you don’t have loops. How can you program without loops, you may ask? In functional programming, loops are replaced by recursion. Let’s rewrite our little example above with recursion: sqrt_newton_recur &lt;- function(a, init, eps = 0.01){ if(abs(init**2 - a) &lt; eps){ result &lt;- init } else { init &lt;- 1/2 * (init + a/init) result &lt;- sqrt_newton_recur(a, init, eps) } return(result) } sqrt_newton_recur(16, 2) ## [1] 4.00122 R is not a pure functional programming language though, so we can still use loops (be it while or for loops) in the bodies of our functions. Actually, for R specifically, it is better, performance-wise, to use loops instead of recursion, because R is not tail-call optimized. I won’t got into the details of what tail-call optimization is but just remember that if performance is important a loop will be faster. However, sometimes, it is easier to write a function using recursion. I personally tend to avoid loops if performance is not important, because I find that code that avoids loops is easier to read and debug. However, knowing that you have can use loops, options is reassuring. In the coming sections I will show you some built-in function that make it possible to avoid writing loops and that don’t rely on recursion, so performance won’t be penalized. 3.1.2 Properties of functions Mathematical functions have a nice property: we always get the same output for a given input. This is called referential transparency and we should aim to write our R functions in such a way. For example, the following function: increment &lt;- function(x){ return(x + 1) } Is a referential transparent function. We always get the same result for any x that we give to this function. This: increment(10) ## [1] 11 will always produce 11. However, this one: increment_opaque &lt;- function(x){ return(x + spam) } is not a referential transparent function, because its value depends on the global variable spam. spam &lt;- 1 increment_opaque(10) ## [1] 11 will only produce 11 if spam = 1. But what if spam = 19? spam &lt;- 19 increment_opaque(10) ## [1] 29 To make increment_opaque() a referential transparent function, it is enough to make spam an argument: increment_not_opaque &lt;- function(x, spam){ return(x + spam) } Now even if there is a global variable called spam, this will not influence our function: spam &lt;- 19 increment_not_opaque(10, 34) ## [1] 44 This is because the variable spam defined in the body of the function is a local variable. It could have been called anything else, really. Avoiding opaque functions makes our life easier. Another property that adepts of functional programming value is that functions should have no, or very limited, side-effects. This means that functions should not change the state of your program. For example this function (which is not a referential transparent function): count_iter &lt;- 0 sqrt_newton_side_effect &lt;- function(a, init, eps = 0.01){ while(abs(init**2 - a) &gt; eps){ init &lt;- 1/2 *(init + a/init) count_iter &lt;&lt;- count_iter + 1 # The &quot;&lt;&lt;-&quot; symbol means that we assign the } # RHS value in a variable in the global environment return(init) } If you look in the environment pane, you will see that count_iter equals 0. Now call this function with the following arguments: sqrt_newton_side_effect(16000, 2) ## [1] 126.4911 print(count_iter) ## [1] 9 If you check the value of count_iter now, you will see that it increased! This is a side effect, because the function changed something outside its scope. It changed a value in the global environment. In general, it is good practice to avoid side-effects. For example, we could make the above function not have any side effects like this: sqrt_newton_count &lt;- function(a, init, count_iter = 0, eps = 0.01){ while(abs(init**2 - a) &gt; eps){ init &lt;- 1/2 *(init + a/init) count_iter &lt;- count_iter + 1 } return(c(init, count_iter)) } Now, this function returns a list with two elements, the result, and the number of iterations it took to get the result: sqrt_newton_count(16000, 2) ## [1] 126.4911 9.0000 Writing to disk is also considered a side effect, because the function changes something (a file) outside its scope. But this cannot be avoided (and it’s actually a good thing to have, functions that can write to disk) so just remember: try to avoid having functions changing variables in the global environment unless you have a very good reason of doing so. Finally, another property of mathematical functions, is that they do one single thing. Functional programming purists also program their functions to do one single task. This has benefits, but can complicate things. The function we wrote previously does two things: it computes the square root of a number and also returns the number of iterations it took to compute the result. However, this is not a bad thing; the function is doing two tasks, but these tasks are related to each other and it makes sense to have them together. My piece of advice: avoid having functions that do too many unrelated things. This makes debugging harder. In conclusion: you should strive for referential transparency, try to avoid side effects unless you have a good reason to have them and try to keep your functions short and do as little tasks as possible. This makes testing and debugging easier, as you will see. 3.2 Map() and Reduce() No introduction to functional programming would be complete without some discussion about the functions Map() and Reduce(). Map() allows you to map your function to every element of a list of arguments and is easy to understand, while Reduce() (sometimes called fold() in other programming languages) reduces a list of values to a single value by successively applying a function. It’s a bit harder to understand, but with some examples it will become clear soon enough. 3.2.1 Map() Now that we have our nice function that computes square roots using Newton’s algorithm, we would like to compute the square root of every element in the following list: numbers &lt;- c(16, 25, 36, 49, 64, 81) sqrt_newton(numbers, init = rep(1, 6), eps = rep(0.001, 6)) ## Warning in while (abs(init^2 - a) &gt; eps) {: the condition has length &gt; 1 ## and only the first element will be used ## Warning in while (abs(init^2 - a) &gt; eps) {: the condition has length &gt; 1 ## and only the first element will be used ## Warning in while (abs(init^2 - a) &gt; eps) {: the condition has length &gt; 1 ## and only the first element will be used ## Warning in while (abs(init^2 - a) &gt; eps) {: the condition has length &gt; 1 ## and only the first element will be used ## Warning in while (abs(init^2 - a) &gt; eps) {: the condition has length &gt; 1 ## and only the first element will be used ## Warning in while (abs(init^2 - a) &gt; eps) {: the condition has length &gt; 1 ## and only the first element will be used ## [1] 4.000001 5.000023 6.000253 7.001406 8.005148 9.014272 We get a whole bunch of nasty warning messages. That is because the condition (init^2 - a) &gt; eps does not make sense for vectors. Here, R tells the user that it only uses the first element and then does the computation anyways. I would prefer if R would stop the execution and print an error message. This would force the user to have to rewrite the function to explicitly take vectors into account. And there is a very simple way of doing it, by using the function Map(): Map(sqrt_newton, numbers, init = 1) ## [[1]] ## [1] 4.000001 ## ## [[2]] ## [1] 5.000023 ## ## [[3]] ## [1] 6.000253 ## ## [[4]] ## [1] 7 ## ## [[5]] ## [1] 8.000002 ## ## [[6]] ## [1] 9.000011 Map() applies a function to every element of a list and returns a list. We could then write a wrapper around Map(): sqrt_newton_vec &lt;- function(numbers, init, eps = 0.01){ return(Map(sqrt_newton, numbers, init, eps)) } sqrt_newton_vec(numbers, 1) ## [[1]] ## [1] 4.000001 ## ## [[2]] ## [1] 5.000023 ## ## [[3]] ## [1] 6.000253 ## ## [[4]] ## [1] 7 ## ## [[5]] ## [1] 8.000002 ## ## [[6]] ## [1] 9.000011 As you can see, we can give a function as an argument to another function. This makes Map() a higher-order function. This is another important concept in functional programming. R has other higher-order functions that work like Map(), such as apply(), lapply(), mapply(), sapply(), vapply() and tapply(). Depending on what you want to do, you will have to use one or the other. apply() and ‘tapply()’ are different from the other *apply() functions, because they work on arrays. You can apply a function on the rows or columns of an array, for example if you want a row-wise sum: a &lt;- cbind(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9)) apply(a, 1, sum) ## [1] 12 15 18 We could use lapply() instead of Map(): lapply(numbers, sqrt_newton, init = 1) ## [[1]] ## [1] 4.000001 ## ## [[2]] ## [1] 5.000023 ## ## [[3]] ## [1] 6.000253 ## ## [[4]] ## [1] 7 ## ## [[5]] ## [1] 8.000002 ## ## [[6]] ## [1] 9.000011 or sapply(): sapply(numbers, sqrt_newton, init = 1) ## [1] 4.000001 5.000023 6.000253 7.000000 8.000002 9.000011 mapply() is different from these two: inits &lt;- c(100, 20, 3212, 487, 5, 9888) mapply(sqrt_newton, numbers, init = inits) ## [1] 4.000284 5.000001 6.000003 7.000006 8.000129 9.000006 What happens here is that sqrt_newton() gets called with following arguments: sqrt_newton(numbers[1], inits[1]) ## [1] 4.000284 sqrt_newton(numbers[2], inits[2]) ## [1] 5.000001 sqrt_newton(numbers[3], inits[3]) ## [1] 6.000003 sqrt_newton(numbers[4], inits[4]) ## [1] 7.000006 sqrt_newton(numbers[5], inits[5]) ## [1] 8.000129 sqrt_newton(numbers[6], inits[6]) ## [1] 9.000006 From the Map()’s documentation, we learn that: `Map()` is wrapper to `mapply()` which does not attempt to simplify the result... All this behaviour can be replicated using loops, but once you get the gist of these functions, you can write code that is shorter and easier to read and unlike in the case of recursion, without any loss in performance (but without any gains either). 3.2.2 Reduce() Reduce() is another very useful higher-order function, especially if you want to avoid loops to make your code easier to read. In some programming languages, Reduce() is called fold(). I think that the following example illustrates the power of Reduce() well: Reduce(`+`, numbers, init = 0) ## [1] 271 Can you guess what happens? Reduce() takes a function as an argument, here the function +2 and then does the following computation: 0 + numbers[1] + numbers[2] + numbers[3]... It applies the user supplied function successively but has to start with something, so we give it the argument init also. This argument is actually optional, but I show it here because in some cases it might be useful to start the computations at another value than 0. This function generalizes functions that only take two arguments. If you were to write a function that returns the minimum between two numbers: my_min &lt;- function(a, b){ if(a &lt; b){ return(a) } else { return(b) } } You could use Reduce() to get the minimum of a list of numbers: Reduce(my_min, numbers) ## [1] 16 Here we don’t supply an init because there is no need for it. Of course R’s built-in min() function works on a list of values. But Reduce() is a very powerful function that can make our life much easier and most importantly avoid writing clumsy loops. This is the end of the introduction to functional programming. Entire books have been written on the subject, such as the upcoming book by Khan (2017) or Lipovaca (2011). If you’re curious about functional programming, you should read these books. For our purposes though, knowing how to write functions, and trying to make them referentially transparent as well as knowing about Map() and Reduce() is enough to get us going. 3.3 Wrap-up Make your functions referentially transparent Avoid side effects (if possible) Make your functions do one thing (if possible) A function that takes another function as an argument is called an higher-order function. You can write your own higher-order functions and this is a way of having short and easily testable functions. Making these functions then work together is trivial and is what makes functional programming very powerful. References "],
["unit-testing.html", "Chapter 4 Unit testing 4.1 Introduction 4.2 Unit testing with the package testthat 4.3 Actually running your tests 4.4 Wrap-up", " Chapter 4 Unit testing 4.1 Introduction Let’s take a look at Wikipedia’s definition of unit testing: In computer programming, unit testing is a software testing method by which individual units of source code, sets of one or more computer program modules together with associated control data, usage procedures, and operating procedures, are tested to determine whether they are fit for use. Intuitively, one can view a unit as the smallest testable part of an application. In procedural programming, a unit could be an entire module, but it is more commonly an individual function or procedure. In object-oriented programming, a unit is often an entire interface, such as a class, but could be an individual method. Unit tests are short code fragments created by programmers or occasionally by white box testers during the development process. It forms the basis for component testing. So unit tests are small pieces of code that test your code. They’re called unit tests, because they test the smallest unit composing your code, in the case of functional programming, the smallest units are functions. You’ve probably been testing your code manually since you’ve started programming. For example, you would simply do something like this: sqrt_newton(4, 1) ## [1] 2.00061 and check if the result is equal to 2 and stop there. Usually you would probably write this in the console and then forget about it. If you need to check again, you would write this small test again in the console. But what if some of your functions have to work together with other functions? Maybe changing something in these other functions will indirectly break in other functions. You would have to retest everything together again! In this chapter you will learn the basics of unit testing, which is simply writing these tests in a file, and running this file each time you change your code. If all your unit tests still pass, you can be more confident that your code works as intended. Unit tests can also be useful to guide you as you program. Some programmers do test-driven development. These programmers start by writing the unit tests first, and then the code to make them pass. This can be useful sometimes, if you don’t really know where you should start but know what you want. 4.2 Unit testing with the package testthat We are going to test the function we wrote in the previous chapter, sqrt_newton(). The basic steps are: Write a file containing your tests Run the tests It’s very simple! You only need to install the testthat package for this. In this section I’ll only show you how to write tests and try to illustrate their usefulness. In the next section, we’ll see how we can run the tests. Below is the code that we are going to put in the file test_my_functions.R: library(&quot;testthat&quot;) test_that(&quot;Test sqrt_newton: positive numeric&quot;,{ expected &lt;- 2 actual &lt;- sqrt_newton(4, 1) expect_equal(expected, actual) }) The syntax of the test is pretty straightforward. We start with a short description of what the test is about, and then we define two variables: the result we expect, and the actual result that is returned by the function we wish to test. When we run this test (we’ll discuss running tests in the next section), this is what we get: Error: Test failed: &#39;Test sqrt_newton: positive numeric&#39; * `expected` not equal to `actual`. 1/1 mismatches [1] 2 - 2 == -0.00061 This is because the value that sqrt_newton() returns is not exactly equal to 2. How to solve this? We could simply check if the difference of the value expected and the value returned is smaller than eps (which is actually how the function works): library(&quot;testthat&quot;) test_that(&quot;Test sqrt_newton: positive numeric&quot;,{ eps &lt;- 0.001 expected &lt;- 2 actual &lt;- sqrt_newton(4, 1, eps = eps) expect_lt(abs(expected - actual), eps) }) There’s no visible output, meaning that the test passes. Don’t worry, we’ll see how to run these tests in the next section, and we’ll get a nice output confirming that tests did, indeed, pass. I didn’t talk about the functions expect_equal() and expect_lt(), but now is the moment. These functions are part of the testthat package and these are what allow you to test your functions. There’s a number of them that allow you to test for a variety of situations. Check the documentation of testthat for more info. Let’s continue to write more tests! library(&quot;testthat&quot;) test_that(&quot;Test sqrt_newton: negative numeric&quot;,{ expect_error(sqrt_newton(-4, 1)) }) We would like our function to return an error message if the user tries to get the square root of a negative number (let’s say we don’t want to generalize our function to complex numbers). But what happens here is that the function runs forever! This is because we are using a while loop whose condition is never fulfilled. This test basically allowed us to find two problems with our function: it doesn’t deal with negative numbers the while loop may run forever if the condition is never fulfilled (for example if eps is too small Let’s rewrite our function to take care of this, one problem at a time: sqrt_newton &lt;- function(a, init, eps = 0.01){ stopifnot(a &gt;= 0) while(abs(init**2 - a) &gt; eps){ init &lt;- 1/2 *(init + a/init) } return(init) } Now let’s run our test again: library(&quot;testthat&quot;) test_that(&quot;Test sqrt_newton: negative numeric&quot;,{ expect_error(sqrt_newton(-4, 1)) }) Again no output, so things are good. Now to the next issue: we need to write a safeguard in the function to avoid having the while loop running for too long. For example if you try to run this: sqrt_newton(49, 1E100000, 1E-100000) You will see that it takes an awful lot of time! Let’s limit the number of iterations to 100. sqrt_newton &lt;- function(a, init, eps = 0.01){ stopifnot(a &gt;= 0) i &lt;- 1 while(abs(init**2 - a) &gt; eps){ init &lt;- 1/2 *(init + a/init) i &lt;- i + 1 if(i &gt; 100) stop(&quot;Maximum number of iterations reached&quot;) } return(init) } Now when we try to run the following expression we get an error message: sqrt_newton(49, 1E100, 1E-100) Error in sqrt_newton(49, 1e+100, 1e-100) : Maximum number of iterations reached But wouldn’t it be better if the user could change the number of iterations himself? sqrt_newton &lt;- function(a, init, eps = 0.01, iter = 100){ stopifnot(a &gt;= 0) i &lt;- 1 while(abs(init**2 - a) &gt; eps){ init &lt;- 1/2 *(init + a/init) i &lt;- i + 1 if(i &gt; iter) stop(&quot;Maximum number of iterations reached&quot;) } return(init) } We can now write some more tests: library(&quot;testthat&quot;) test_that(&quot;Test sqrt_newton: not enough iterations&quot;,{ expect_error(sqrt_newton(4, 1E100, 1E-100, iter = 100)) }) 4.3 Actually running your tests One of the easiest ways to run your tests is when your developing a package. We are going to see this in the next chapter, but for now, let’s suppose that we have a folder called my_project with the code inside of it. There’s a file called my_functions.R and another file called test_my_functions.R which contain the functions you programmed and the unit tests that go with it respectively. The file test_my_functions.R contains the following source code: library(&quot;testthat&quot;) test_that(&quot;Test sqrt_newton: positive numeric&quot;,{ eps &lt;- 0.001 expected &lt;- 2 actual &lt;- sqrt_newton(4, 1, eps = eps) expect_lt(abs(expected - actual), eps) }) test_that(&quot;Test sqrt_newton: negative numeric&quot;,{ expect_error(sqrt_newton(-4, 1)) }) test_that(&quot;Test sqrt_newton: not enough iterations&quot;,{ expect_error(sqrt_newton(4, 1E100, 1E-100, iter = 100)) }) Then you simply run the following in the console: test_file(&quot;test_my_functions.R&quot;) of course you have to make sure that you are in the correct working directory. This can be tricky, and is one of the reasons why it’s easier to run your tests when you’re developing a package. This is the output we get: ... DONE ================================================================================ See the three dots on the first line? Each dot represents a test that passed successfully. Let’s add a test that will not pass on purpose, just to see what happens: test_that(&quot;Test sqrt_newton: wrong on purpose&quot;,{ eps &lt;- 0.001 expected &lt;- 12 actual &lt;- sqrt_newton(4, 1, eps = eps) expect_lt(abs(expected - actual), eps) }) This is the output we get now: ...1 Failed ------------------------------------------------------------------------------ 1. Failure: Test sqrt_newton: wrong on purpose (@test_my_functions.R#22) ------------ abs(expected - actual) is not strictly less than `eps`. Difference: 10 DONE ================================================================================ You can then go back to the file that contains the tests and correct them. If all your tests are in a separate folder, you can use the function test_dir() to test all the functions in a given folder. The files containing your tests should all start with the string test. You could have a file called run_tests.R on the root of the directory and this file could contain the following: library(&quot;testthat&quot;) test_dir(&quot;tests&quot;) You could then run your tests by running this file. You might also be tempted to write a bash script on GNU/Linux distributions or on macOS: #!/bin/sh Rscript -e &quot;testthat::test_that(&#39;/whole/path/to/your/tests&#39;)&quot; but you’ll probably only get burned because when you run this script, a new R session is started which does not know anything about your functions in your file my_functions.R. Managing the working directory is quite a pain. This is why in the next chapter we are going to start learning about packages and why writing or own packages to clean datasets is the best possible way to write your code. 4.4 Wrap-up Unit tests are a way of testing your code, and more specifically your functions The basic workflow is to write your code, write tests, and check if your tests pass You can also start with the tests and then write or modify your code to make them pass We didn’t talk about coverage yet. Are you sure that you test every line of your function? No you’re not. In the next chapter I’ll show how can be sure to test each line of your function with the covr package. "],
["packages.html", "Chapter 5 Packages 5.1 Why you need your own packages in your life 5.2 R packages: the basics", " Chapter 5 Packages 5.1 Why you need your own packages in your life One of the reasons you might have tried R in the first place is the abundance of packages. As I’m writing these lines (in August 2016), 8922 packages are available on CRAN. That’s almost over 9000. This is an absolutely crazy amount of packages! Chances are that if you want to do something, there’s a package for that (I’ll stop it here with the lame references, promise!). So why the heck should you write your own packages? After all, with 8922 packages you’re sure to find something that suits your needs, right? No. Simply because the data sets that you’re working with are probably unique to your workplace or maybe what you want to do with them is unique to your needs. You won’t find a package that will take care of cleaning your data for you. Ok, but is it necessary to write a package? Why not just write functions inside some scripts and then simply run these scripts? This seems like a valid solution at first. However, it quickly becomes tedious, especially if you have multiple scripts scattered around your computer or inside different subfolders. You’ll also have to write the documentation on separate files and these can easily get lost or become outdated. Having everything inside a package takes care of these headaches for you. And code that is inside packages is very easy to test, especially if you’re using Rstudio. It also makes it possible to use the wonderful covr package, which tells you which lines in which functions are called by your tests. If some lines are missing, write tests that invoke them and increase the coverage of your tests! As I mentioned in the introduction, if you want to learn much more than I’ll show about packages read Wickham (2014). I will only show you the basics, but it should be enough to get you productive. One last thing: if you don’t know git, you really should learn git. I won’t talk about it here, because there’s a ton of books on git, such as Silverman (2013). I learned by reading it and googling whenever I had a problem. Learning git is really worth it, especially if you’re collaborating with some colleagues on your packages. 5.2 R packages: the basics References "],
["final-words.html", "Chapter 6 Final Words", " Chapter 6 Final Words We have finished a nice book. "],
["references.html", "References", " References "]
]
