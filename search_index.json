[
["index.html", "Functional programming and unit testing for data munging Chapter 1 Why this book? 1.1 Motivation 1.2 Who am I? 1.3 Thanks", " Functional programming and unit testing for data munging Bruno Rodrigues 2016-08-17 Chapter 1 Why this book? This short book serves to show how functional programming and unit testing can be useful for the task of data munging. This book is not an in-depth guide to functional programming, nor unit testing with R. There are better resources to learn functional progamming and unit testing with R. But I will introduce the main ideas. I will also show how to build your own R package that will hold all the code to clean your data and accompagnying documentation. Again, there are great resources online to learn about packages. I will just cover the basics, and explain why having your code inside a packages makes sense when using functional programming and unit tests with R. This book is not an introduction to R either. I will assume that you have intermediate knowledge of R. 1.1 Motivation Functional programming has very nice features that make working on data sets much more pleasant. It is common that you have to repeat the same instructions over and over again for different data sets that look very similar (for example, same, or similar column names). Of course, it is possible to loop over these data sets and repeat a set of instructions that change these data sets. However, we will see why a functional programming approach is to be preferred. Unit testing then allows you to make sure that the functions you want to apply to your data sets actually do what you really want them to do. Knowing and applying these two concepts together will make you hopefully a better data analyst. 1.2 Who am I? I use R daily at my current job, and discovered R some years ago while I was at the University of Strasbourg. I’m not an R developer, and don’t have a CS background. Most, if not everything, that I know about R is self-taught. I hope however that you will find this book useful. You can follow me on twitter or check my blog. 1.3 Thanks I’d like to thank Ross Ihaka and Robert Gentleman for developing the R programming language. Many thanks to Hadley Wickham for all the wonderful packages he developed that make R much more pleasant to use. Thanks to Yihui Yie for bookdown without which this book would not exist (at least not in this very nice format). Thanks to Hans-Martin von Gaudecker for introducing me to unit testing and writing elegant code. The PEP 8 style guidelines will forever remain etched in my brain. Finally I have to thank my wife for putting up with my endless rants against people not using functional programming nor testing their code (or worse, using proprietary software!). "],
["intro.html", "Chapter 2 Introduction 2.1 Getting R 2.2 A short overview of functional programming 2.3 A short overview of unit testing", " Chapter 2 Introduction 2.1 Getting R Since I’m assuming you have an intermediate level in R, you already should have R and Rstudio installed on your machine. However, you may lack some of the following packages that are needed to follow the examples in this book: covr dplyr lazyeval lubridate memoise readr roxygen2 stringr testthat tibble tidyr If you’re missing some or all of these packages, install them. You’ll notice that most, if not all, of these packages were authored or co-authored by Hadley Wickham, currently chief scientist at Rstudio. 2.2 A short overview of functional programming What is functional programming? Wikipedia tells us the following: In computer science, functional programming is a programming paradigm —a style of building the structure and elements of computer programs— that treats computation as the evaluation of mathematical functions and avoids changing state and mutable data. It is a declarative programming paradigm, which means programming is done with expressions or declarations instead of statements. In functional code, the output value of a function depends only on the arguments that are input to the function, so calling a function f twice with the same value for an argument x will produce the same result f(x) each time. Eliminating side effects, i.e. changes in state that do not depend on the function inputs, can make it much easier to understand and predict the behavior of a program, which is one of the key motivations for the development of functional programming. That’s the first paragraph of the Wikipedia page and it’s quite heavy already! So let’s try to decrypt what is said in this paragraph. Functional programming is a programming paradigm. You may have heard of object oriented programming, or imperative programming before. You actually probably program in an imperative way without knowing it. Imperative programming is usually how programming is taught at universities, and most people then keep on programming in this way. Usually, people that write code in an imperative way tend to write very long scripts that change the state of the program gradually. In the case of a statistician (I will use the word ‘statistician’ to mean any person that works with datasets. Be it an economist, biologist, data scientist, etc.) this usually means loading a dataset, doing whatever you have to do by writing each step on a file, then running everything. Sometimes you have to save temporary datasets, and then write other scripts that do a series of computations on these temporary datasets and then not forget to delete said temporary datasets. Functional programming is different, in that you write functions that do one single task and then call these functions successively on your data set. These functions can be used for any other project, can be documented and tested. It is also easier to automate tasks and navigate through the code. Since one function does one single task, if you’re looking for the line of code that creates variable X, just look in the function called create_var_X(), instead of scrolling aimlessly through a 1000 lines long script. You can also be sure that your functions do not do anything else (basically, this is what is meant by “eliminating side effects”) than the single task you gave them. You can trust your functions. 2.3 A short overview of unit testing At the end of the last section I wrote that you can trust your functions. Is that true though? Functional programming can make your life easier, but it does not prevent you from introducing bugs in your code. However, what functional programming makes easily possible, is to very easily and effectively test your code thanks to unit testing. You probably already test your code, by hand. You write some loop that is supposed to sum the first 10 integers and then you try it out and check if, indeed, your loop returns 55. Because this is the correct result, you save your work and continue programming something else, and so on. Unit testing is this, but in an automated way. Instead of just trying things out in the interpreter, you write unit tests. You write code that actually checks your functions. You save this unit tests somewhere, and then re-run them whenever you make changes to your code. Even if you don’t change some parts of your code, you re-run every unit test. Because you actually never know what may happen. Maybe changing a single line in one of your functions introduced some unforeseen consequences that breaks functionality some place else. When you change code, and all your unit tests still pass, then you can be confident that your code is correct (actually, don’t be too confident, because maybe you didn’t write enough unit tests to cover every case. But we will see how we can be sure there is enough coverage). "],
["fprog.html", "Chapter 3 Functional Programming 3.1 Introduction 3.2 Map() and Reduce() 3.3 Wrap-up", " Chapter 3 Functional Programming 3.1 Introduction 3.1.1 Function definitions As mentioned in the functional programming overview functional programming is one of the numerous ways to write code. In functional programming, you write functions that do the computations and then as the user, you call these functions to work for you. You should be familiar with function definitions in R. For example, suppose you want to compute the square root of a number and want to do so using Newton’s algorithm: sqrt_newton &lt;- function(a, init, eps = 0.01){ while(abs(init**2 - a) &gt; eps){ init &lt;- 1/2 *(init + a/init) } return(init) } You can then use this function to get the square root of a number: sqrt_newton(16, 2) ## [1] 4.00122 We are using a while loop inside the body1 of the function. In pure functional programming languages, like Haskell, you don’t have loops. How can you program without loops, you may ask? In functional programming, loops are replaced by recursion. Let’s rewrite our little example above with recursion: sqrt_newton_recur &lt;- function(a, init, eps = 0.01){ if(abs(init**2 - a) &lt; eps){ result &lt;- init } else { init &lt;- 1/2 * (init + a/init) result &lt;- sqrt_newton_recur(a, init, eps) } return(result) } sqrt_newton_recur(16, 2) ## [1] 4.00122 R is not a pure functional programming language though, so we can still use loops (be it while or for loops) in the bodies of our functions. Actually, for R specifically, it is better, performance-wise, to use loops instead of recursion, because R is not tail-call optimized. I won’t got into the details of what tail-call optimization is but just remember that if performance is important a loop will be faster. However, sometimes, it is easier to write a function using recursion. I personally tend to avoid loops if performance is not important, because I find that code that avoids loops is easier to read and debug. However, knowing that you have can use loops, options is reassuring. In the coming sections I will show you some built-in function that make it possible to avoid writing loops and that don’t rely on recursion, so performance won’t be penalized. 3.1.2 Properties of functions Mathematical functions have a nice property: we always get the same output for a given input. This is called referential transparency and we should aim to write our R functions in such a way. For example, the following function: increment &lt;- function(x){ return(x + 1) } Is a referential transparent function. We always get the same result for any x that we give to this function. This: increment(10) ## [1] 11 will always produce 11. However, this one: increment_opaque &lt;- function(x){ return(x + spam) } is not a referential transparent function, because its value depends on the global variable spam. spam &lt;- 1 increment_opaque(10) ## [1] 11 will only produce 11 if spam = 1. But what if spam = 19? spam &lt;- 19 increment_opaque(10) ## [1] 29 To make increment_opaque() a referential transparent function, it is enough to make spam an argument: increment_not_opaque &lt;- function(x, spam){ return(x + spam) } Now even if there is a global variable called spam, this will not influence our function: spam &lt;- 19 increment_not_opaque(10, 34) ## [1] 44 This is because the variable spam defined in the body of the function is a local variable. It could have been called anything else, really. Avoiding opaque functions makes our life easier. Another property that adepts of functional programming value is that functions should have no, or very limited, side-effects. This means that functions should not change the state of your program. For example this function (which is not a referential transparent function): count_iter &lt;- 0 sqrt_newton_side_effect &lt;- function(a, init, eps = 0.01){ while(abs(init**2 - a) &gt; eps){ init &lt;- 1/2 *(init + a/init) count_iter &lt;&lt;- count_iter + 1 # The &quot;&lt;&lt;-&quot; symbol means that we assign the } # RHS value in a variable in the global environment return(init) } If you look in the environment pane, you will see that count_iter equals 0. Now call this function with the following arguments: sqrt_newton_side_effect(16000, 2) ## [1] 126.4911 print(count_iter) ## [1] 9 If you check the value of count_iter now, you will see that it increased! This is a side effect, because the function changed something outside its scope. It changed a value in the global environment. In general, it is good practice to avoid side-effects. For example, we could make the above function not have any side effects like this: sqrt_newton_count &lt;- function(a, init, count_iter = 0, eps = 0.01){ while(abs(init**2 - a) &gt; eps){ init &lt;- 1/2 *(init + a/init) count_iter &lt;- count_iter + 1 } return(c(init, count_iter)) } Now, this function returns a list with two elements, the result, and the number of iterations it took to get the result: sqrt_newton_count(16000, 2) ## [1] 126.4911 9.0000 Writing to disk is also considered a side effect, because the function changes something (a file) outside its scope. But this cannot be avoided (and it’s actually a good thing to have, functions that can write to disk) so just remember: try to avoid having functions changing variables in the global environment unless you have a very good reason of doing so. Finally, another property of mathematical functions, is that they do one single thing. Functional programming purists also program their functions to do one single task. This has benefits, but can complicate things. The function we wrote previously does two things: it computes the square root of a number and also returns the number of iterations it took to compute the result. However, this is not a bad thing; the function is doing two tasks, but these tasks are related to each other and it makes sense to have them together. My piece of advice: avoid having functions that do too many unrelated things. This makes debugging harder. In conclusion: you should strive for referential transparency, try to avoid side effects unless you have a good reason to have them and try to keep your functions short and do as little tasks as possible. This makes testing and debugging easier, as you will see. 3.2 Map() and Reduce() No introduction to functional programming would be complete without some discussion about the functions Map() and Reduce(). Map() allows you to map your function to every element of a list of arguments and is easy to understand, while Reduce() (sometimes called fold() in other programming languages) reduces a list of values to a single value by successively applying a function. It’s a bit harder to understand, but with some examples it will become clear soon enough. 3.2.1 Map() Now that we have our nice function that computes square roots using Newton’s algorithm, we would like to compute the square root of every element in the following list: numbers &lt;- c(16, 25, 36, 49, 64, 81) sqrt_newton(numbers, init = rep(1, 6), eps = rep(0.001, 6)) ## Warning in while (abs(init^2 - a) &gt; eps) {: the condition has length &gt; 1 ## and only the first element will be used ## Warning in while (abs(init^2 - a) &gt; eps) {: the condition has length &gt; 1 ## and only the first element will be used ## Warning in while (abs(init^2 - a) &gt; eps) {: the condition has length &gt; 1 ## and only the first element will be used ## Warning in while (abs(init^2 - a) &gt; eps) {: the condition has length &gt; 1 ## and only the first element will be used ## Warning in while (abs(init^2 - a) &gt; eps) {: the condition has length &gt; 1 ## and only the first element will be used ## Warning in while (abs(init^2 - a) &gt; eps) {: the condition has length &gt; 1 ## and only the first element will be used ## [1] 4.000001 5.000023 6.000253 7.001406 8.005148 9.014272 We get a whole bunch of nasty warning messages. That is because the condition (init^2 - a) &gt; eps does not make sense for vectors. Here, R tells the user that it only uses the first element and then does the computation anyways. I would prefer if R would stop the execution and print an error message. This would force the user to have to rewrite the function to explicitly take vectors into account. And there is a very simple way of doing it, by using the function Map(): Map(sqrt_newton, numbers, init = 1) ## [[1]] ## [1] 4.000001 ## ## [[2]] ## [1] 5.000023 ## ## [[3]] ## [1] 6.000253 ## ## [[4]] ## [1] 7 ## ## [[5]] ## [1] 8.000002 ## ## [[6]] ## [1] 9.000011 Map() applies a function to every element of a list and returns a list. We could then write a wrapper around Map(): sqrt_newton_vec &lt;- function(numbers, init, eps = 0.01){ return(Map(sqrt_newton, numbers, init, eps)) } sqrt_newton_vec(numbers, 1) ## [[1]] ## [1] 4.000001 ## ## [[2]] ## [1] 5.000023 ## ## [[3]] ## [1] 6.000253 ## ## [[4]] ## [1] 7 ## ## [[5]] ## [1] 8.000002 ## ## [[6]] ## [1] 9.000011 As you can see, we can give a function as an argument to another function. This makes Map() a higher-order function. This is another important concept in functional programming. R has other higher-order functions that work like Map(), such as apply(), lapply(), mapply(), sapply(), vapply() and tapply(). Depending on what you want to do, you will have to use one or the other. apply() and ‘tapply()’ are different from the other *apply() functions, because they work on arrays. You can apply a function on the rows or columns of an array, for example if you want a row-wise sum: a &lt;- cbind(c(1, 2, 3), c(4, 5, 6), c(7, 8, 9)) apply(a, 1, sum) ## [1] 12 15 18 We could use lapply() instead of Map(): lapply(numbers, sqrt_newton, init = 1) ## [[1]] ## [1] 4.000001 ## ## [[2]] ## [1] 5.000023 ## ## [[3]] ## [1] 6.000253 ## ## [[4]] ## [1] 7 ## ## [[5]] ## [1] 8.000002 ## ## [[6]] ## [1] 9.000011 or sapply(): sapply(numbers, sqrt_newton, init = 1) ## [1] 4.000001 5.000023 6.000253 7.000000 8.000002 9.000011 mapply() is different from these two: inits &lt;- c(100, 20, 3212, 487, 5, 9888) mapply(sqrt_newton, numbers, init = inits) ## [1] 4.000284 5.000001 6.000003 7.000006 8.000129 9.000006 What happens here is that sqrt_newton() gets called with following arguments: sqrt_newton(numbers[1], inits[1]) ## [1] 4.000284 sqrt_newton(numbers[2], inits[2]) ## [1] 5.000001 sqrt_newton(numbers[3], inits[3]) ## [1] 6.000003 sqrt_newton(numbers[4], inits[4]) ## [1] 7.000006 sqrt_newton(numbers[5], inits[5]) ## [1] 8.000129 sqrt_newton(numbers[6], inits[6]) ## [1] 9.000006 From the Map()’s documentation, we learn that: `Map()` is wrapper to `mapply()` which does not attempt to simplify the result... All this behaviour can be replicated using loops, but once you get the gist of these functions, you can write code that is shorter and easier to read and unlike in the case of recursion, without any loss in performance (but without any gains either). 3.2.2 Reduce() Reduce() is another very useful higher-order function, especially if you want to avoid loops to make your code easier to read. In some programming languages, Reduce() is called fold(). I think that the following example illustrates the power of Reduce() well: Reduce(`+`, numbers, init = 0) ## [1] 271 Can you guess what happens? Reduce() takes a function as an argument, here the function +2 and then does the following computation: 0 + numbers[1] + numbers[2] + numbers[3]... It applies the user supplied function successively but has to start with something, so we give it the argument init also. This argument is actually optional, but I show it here because in some cases it might be useful to start the computations at another value than 0. This function generalizes functions that only take two arguments. If you were to write a function that returns the minimum between two numbers: my_min &lt;- function(a, b){ if(a &lt; b){ return(a) } else { return(b) } } You could use Reduce() to get the minimum of a list of numbers: Reduce(my_min, numbers) ## [1] 16 Here we don’t supply an init because there is no need for it. Of course R’s built-in min() function works on a list of values. But Reduce() is a very powerful function that can make our life much easier and most importantly avoid writing clumsy loops. This is the end of the introduction to functional programming. Entire books have been written on the subject, such as the upcoming book by Khan (2017) or Lipovaca (2011). If you’re curious about functional programming, you should read these books. For our purposes though, knowing how to write functions, and trying to make them referentially transparent as well as knowing about Map() and Reduce() is enough to get us going. 3.3 Wrap-up Make your functions referentially transparent Avoid side effects (if possible) Make your functions do one thing (if possible) A function that takes another function as an argument is called an higher-order function. You can write your own higher-order functions and this is a way of having short and easily testable functions. Making these functions then work together is trivial and is what makes functional programming very powerful. References "],
["unit-tests.html", "Chapter 4 Unit tests 4.1 Introduction to unit testing", " Chapter 4 Unit tests 4.1 Introduction to unit testing "],
["packages.html", "Chapter 5 Packages 5.1 Introduction to R packages", " Chapter 5 Packages 5.1 Introduction to R packages "],
["final-words.html", "Chapter 6 Final Words", " Chapter 6 Final Words We have finished a nice book. "],
["references.html", "References", " References "]
]
